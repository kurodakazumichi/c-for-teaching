# 値渡しとポインタ渡し

今回もポインタ関係の話で、[前回の続き](../09_03_pointer/index.md)となり、関数と関連の深い**値渡し**と**ポインタ渡し**に関する資料になります。



※ポインタ渡しではなく参照渡しという言葉が使われる事もありますが、C++になると**値渡し、参照渡し、ポインタ渡し**と3種類が登場します。

C言語で参照渡しと言っているものは実質、C++のポインタ渡しに該当します。

この先、ポインタ渡しと参照渡しの違いで混乱しないためにも、参照渡しではなく**ポインタ渡し**という言葉を使うことにします。



## 値渡しとは

今回は**ポインタ渡し**の前に、以下のプログラムを参考に、**値渡し**というのはつまりメモリの中はどうなってるんだぜ？ということを見ていきたいと思います。

```c
#include <stdio.h>

void reset(int p) {
	p = 0;
}

int main(void)
{
    // ①変数を10で初期化
	int a = 10;

    // ①関数実行
	reset(a);
	
    // ③aの値を表示
	printf("%d", a); // 10と表示される
	return 0;
}
```



### ①変数を10で初期化

`int a = 10;`という処理では、変数aのためにメモリが確保され、そこに`10`という値が格納されます。

イメージだとこんな感じ、今回は1番地から4byteのメモリを確保したことにしましょう。

![image-20210410050036907](./images/image-20210410050036907.png)



### ②関数実行

次に関数を実行する部分について、メモリの中について迫っていきたいと思います。



以下では`reset関数`を実行していますが、関数を呼び出すときにはまず、**この関数を動かすのに必要なメモリ**が確保されます。

```c
// ①関数実行
reset(a);
```



**関数を動かすために必要なメモリ**というのは細かい事を言えばあれこれとあるのですが、今回は変数について着目します。

`reset関数`は引数で`int型の変数`を受け取るようになっていますが、引数も変数ですのでメモリが必要です。

```c
void reset(int p) {
	p = 0;
}
```



メモリは以下のような感じで、`reset関数`で使う必要な`変数p`のメモリを確保します。

![image-20210410050108415](./images/image-20210410050108415.png)

そして関数を呼び出すときに引数に`a`を指定していますが、これは今しがた確保した`引数p`のメモリに`変数a`の値をセットするということになります。

```c
reset(a);
```



メモリではこんな感じになります。

![image-20210410050624193](./images/image-20210410050624193.png)

次は`reset関数`の中について見ていきます。

```c
void reset(int p) {
	p = 0;
}
```



この処理では`p`に`0`を代入しているので、メモリの中は以下のようになります。

![image-20210410050948945](./images/image-20210410050948945.png)



そして関数の処理が終わると、関数の為に確保したメモリは自動的に解放されます。

![image-20210410051203616](./images/image-20210410051203616.png)



### ③aの値を表示

この状態で、`変数a`を表示するとどうなるかといえば、メモリを見れば明らかだと思いますが

`変数a`の値は`10`なので、`10`が表示されるというわけです。



```c
// ③aの値を表示
printf("%d", a); // 10と表示される
```



今回の`reset関数`というのは、自分のために用意されたメモリの中身を書き換えて、そのメモリはすぐに解放されるので、何もしていないわけではないけれど、意味のある事はしていない処理になっているというわけです。



これが**値渡し**と呼ばれるものになります。

次に**ポインタ渡し**について解説していきますが、実質**やっていることは値渡しと違いがない**です。

ただ**渡すモノが違うだけ**です。





## ポインタ渡しとは

関数の引数にポインタ、つまりメモリのアドレスを渡すことをいいます。

今回は以下のプログラムについて、またメモリの内部を追っていきたいと思います。

```c
#include <stdio.h>

void reset(int* p) {
	*p = 0;
}

int main(void)
{
    // ①変数を10で初期化
	int a = 10;

    // ①関数実行
	reset(&a);
	
    // ③aの値を表示
	printf("%d", a); // 0と表示される
	return 0;
}
```



### ①変数を10で初期化

`int a = 10;`という処理によって、変数aのためのメモリが確保される、これは値渡しと同じです。

![image-20210409085540688](./images/image-20210409085540688.png)

### ②関数実行

以下の関数実行について見ていきます。

```c
reset(&a);
```



関数実行も値渡しと同じで、まず関数に必要なメモリが確保されます。

`reset関数`の引数は`int* p`でポインタだという違いはありますが、今回はポインタも4byteという事にするので、メモリの中的には値渡しの時と同じです。

![image-20210410052542252](./images/image-20210410052542252.png)



関数を呼び出す際に、`reset(&a);`として、`引数`に`変数a`の**アドレス**を渡していますので、`引数p`には`変数a`の**アドレス**が渡されます。

![image-20210410054401364](./images/image-20210410054401364.png)



次に`reset関数`の内部について見ていきます。

```c
void reset(int* p) {
	*p = 0;
}
```



`*p = 0;`という処理をしていますが、これはポインタがさす場所の値を0にするということです。

現状だと`*p`は`変数a`を指しているので、**変数aの値が0になる**ということになります。



メモリのイメージも確認しておきます。

![](./images/image-20210410053858827.png)



そして関数の処理が終わると、関数のために確保したメモリは解放されます。

![image-20210410054504443](./images/image-20210410054504443.png)



### ③aの値を表示

この状態で、`変数a`を表示するとどうなるかといえば、メモリを見れば明らかだと思いますが

`変数a`の値は`0`なので、`0`が表示されるというわけです。



```c
// ③aの値を表示
printf("%d", a); // 0と表示される
```



メモリの中で見れば特別な事をしている感じはしないというか、今まで解説してきたことを正しく理解していれば、「うん、まぁそうなるよね」というだけの話かとは思います。



## まとめ

今回は**値渡し**と**ポインタ渡し**についてメモリに言及した解説をしてみました。

極端に行ってしまえば、**値渡し**も**ポインタ渡し**も**渡す物が違う**だけです。



引数で**変数の値**を渡すと、関数の内部では大元の変数の値を変える事はできない(アドレスわからないからね)

**変数のアドレス**を渡すと、アドレスが分かれば大元の変数の値も変えられるという違いがあるだけとなります。



また、この**ポインタ渡し**というのは書籍によっては**参照渡し**と書かれていることもあるかと思います。

この**参照**という言葉は、**変数の参照先**、つまりメモリ上のアドレスを意味しています。



アドレスが分かれば、参照できるわけですし、**変数の参照先を渡す**ので**参照渡し**と呼ぶと捉えれば、これはこれで間違いだとは思いません。



ただアドレスを直接渡すというのは危険もはらんでいて、C++ではより安全にアドレスを渡す書き方があります。

このより安全にアドレスを渡す方を**参照渡し**とよび、ポインタをほいっと渡すのは**ポインタ渡し**のように区別されていたりします。

まぁここらへんはC++の資料を作る日があれば、そちらで言及したいと思います。





# Tips①：値渡しでもアドレスが渡ってくれば...

以下の処理は普通はこんな書き方はしませんが、道理さえ通っていれば動きはしますよというコードです。

C言語は良くも悪くも書いたとおりに動きますので、危険なコードやトリッキーなコードでも道理さえ通ってれば動くのです。

実務でこんなコードを書いていたらビンタものですが、個人でいろいろ試して検証する分には良い言語ですね😊

```c
#include <stdio.h>

void reset(int p) {
    // pはint型だけど、中身の数値は変数のアドレスが入ってるというのであれば
    // 無理やりint型のポインタにキャストして、ポインタとして扱ってしまうこともできる
	*((int *)p) = 0;
}

int main(void)
{
	int a = 10;

    // アドレスといってもただの数値なので、int型に渡す事は可能
	reset(&a);
	
	printf("%d", a);
	return 0;
}
```







# Tips②：関数を実行するとは？

関数を実行する、はたまた関数を呼び出すと言ったりもしますが、そもそも関数呼び出しとはなんなのか、について少し触れます。

関数というのも、メモリのどこかに存在していて、関数の存在する場所(つまり関数のアドレス)というものがあります。



メモリのイメージとしてはこんな感じです

![image-20210410041941419](./images/image-20210410041941419.png)



コンピューターがプログラムを実行する時は**プログラムカウンタ**といって、今実行している処理の場所(アドレス)を保持していて、**プログラムカウンタ**が示している場所にある処理を実行しています。

処理が実行されると、**プログラムカウンタ**が増え、またその場所の処理を実行するという事を繰り返しています。



上記のメモリの例であれば

**プログラムカウンタ**に`11`が入っていれば`main関数`の最初から処理が動きますし

**プログラムカウンタ**に`21`を入れてしまえば、`reset関数`の最初から処理が動くというシンプルなものです。



**関数を呼び出す**というのは、**プログラムカウンタ**に処理したい場所のアドレスをセットするという事になります。



ちなみに関数名というのはその関数の存在するアドレスを表しています。

今回例にしていた`reset関数`の呼び出しについてさらに細かく突っ込んでみると



```c
// 関数名というのは関数のある場所→つまりアドレスである
reset(a);

// reset関数のアドレスが0x12345678だったとすると
// 以下のように書いても同じことである。
0x12345678(a);
```



C言語の書籍とかで、演算子の章をよく見てみると`()`が関数呼び出しという演算子で登場しているのではないかなと思います。

`()`という演算子は、`()`の前にあるアドレスを**プログラムカウンタ**にセットしつつ、その関数に必要なメモリを確保するという**演算**を行うものだったというわけですね。