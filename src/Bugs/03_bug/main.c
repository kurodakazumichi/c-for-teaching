//-----------------------------------------------------------------------------
// 二分探索法で配列の中から数値を検索(再帰処理)
//
// 要素が100個ある配列の中から、指定した数値のある場所を調べたい。
// なるべく処理が少なくすむように二分探索法アルゴリズムを使ってみたのだが
// どうにもうまくいっていない。
// 原因を調査して、不具合を修正してほしい。
// また二分探索法がわからなければ、そちらから調べてもらいたい。
//
// ※解答はソースコードの下の方に記載しています。
//-----------------------------------------------------------------------------
#include <stdio.h>

// 関数プロトタイプ宣言
int search(int num, const int nums[], int s, int e);
void show(int num, int foundIndex, int nums[]);

// エントリーポイント
int main(void)
{
	const int NUMS[] = {
		 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,
		10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
		20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
		30, 31, 32, 33, 34, 35, 36, 37, 38, 39,
		40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
		50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
		60, 61, 62, 63, 64, 65, 66, 67, 68, 69,
		70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
		80, 81, 82, 83, 84, 85, 86, 87, 88, 89,
		90, 91, 92, 93, 94, 95, 96, 97, 98, 99
	};

	// 43を探す
	show(43, search(43, NUMS, 0, 99), NUMS);

	// -100を探す
	show(-100, search(-100, NUMS, 0, 99), NUMS);
}

// 二分探索法による再帰処理で nums の中から num を探す。
// 見つかれば見つかった場所の配列Indexを返し
// 見つからなければ-1を返す
int search(int num, const int nums[], int s, int e)
{
	// 始点と終点が入れ替わっていたら見つからなかったということ
	if (e < s) return -1;

	// 中央のIndexを求める
	int c = (s + e) / 2;

	// 一致するものが見つかったらその場所を返す
	if (nums[c] == num) {
		return c;
	}

	// 探しているもの数が右側にある場合は、開始位置を変えて再探索
	if (nums[c] > num) {
		return search(num, nums, c + 1, e);
	}

	// 探しているもの数が左側にある場合は、終了位置を変えて再探索
	if (num > nums[c]) {
		return search(num, nums, s, c - 1);
	}
}

// 結果表示
void show(int num, int foundIndex, int nums[]) 
{
	if (0 <= foundIndex) {
		printf("NUMS[%d] = %d\n", foundIndex, nums[foundIndex]);
	}
	else {
		printf("%d 見つかりませんでした。", num);
	}
}






















//-----------------------------------------------------------------------------
// 解答
// 二分探索法は探索する範囲を絞りながら検索していく手法である。
// また検索する対象の配列は昇順で整列されていることが前提となった処理である。
// 今回の配列は要素数が100なのでまず
// NUMS[0] と NUMS[99] の真ん中に該当する NUMS[49]に目を付ける
// NUMS[49] と 探したい数値 99を比較し
// NUMS[49]より大きいなら99は NUMS[50] ～ NUMS[99]にあることになる
// 逆に小さいのであれば
// NUMS[0] ～ NUMS[48] にある事になる
// 問題はこの大小の比較の条件式が逆になってしまっている部分にある。
// 正しい判定に修正したsearch関数は以下の通りである。
#if 0

int search(int num, const int nums[], int s, int e)
{
	// 始点と終点が入れ替わっていたら見つからなかったということ
	if (e < s) return -1;

	// 中央のIndexを求める
	int c = (s + e) / 2;

	// 一致するものが見つかったらその場所を返す
	if (nums[c] == num) {
		return c;
	}

	// 探しているもの数が右側にある場合は、開始位置を変えて再探索
	if (nums[c] < num) {
		return search(num, nums, c + 1, e);
	}

	// 探しているもの数が左側にある場合は、終了位置を変えて再探索
	if (num < nums[c]) {
		return search(num, nums, s, c - 1);
	}
}

#endif







